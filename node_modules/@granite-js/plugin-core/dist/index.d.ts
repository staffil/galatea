import * as z from "zod";
import * as swc from "@swc/core";
import * as esbuild$1 from "esbuild";
import * as esbuild from "esbuild";
import { HandleFunction } from "connect";
import { FastifyPluginAsync, FastifyPluginCallback } from "fastify";
import * as ws from "ws";
import * as babel from "@babel/core";

//#region src/types/BuildConfig.d.ts
interface BuildConfig {
  /**
   * Build platform
   */
  platform: 'ios' | 'android';
  /**
   * Entry file path
   */
  entry: string;
  /**
   * Build output file path
   */
  outfile: string;
  /**
   * Source map output file path
   *
   * @default `${outfile}.map`
   */
  sourcemapOutfile?: string;
  /**
   * Module resolution configuration
   */
  resolver?: ResolverConfig;
  /**
   * Transformer configuration
   */
  transformer?: {
    transformSync?: TransformSync;
    transformAsync?: TransformAsync;
  };
  /**
   * esbuild configuration
   */
  esbuild?: EsbuildConfig;
  /**
   * Custom babel configuration
   */
  babel?: BabelConfig;
  /**
   * Custom swc configuration
   */
  swc?: SwcConfig;
  /**
   * Additional data
   *
   * Included in the build result data, used for post-processing based on specific values
   * (eg. add specific extra data in preset, and distinguish which preset the build result is from)
   *
   * ```js
   * const result = new Bundler({
   *   bundlerConfig: {
   *     buildConfig: {
   *       extra: {
   *         reanimated: 3,
   *       },
   *     },
   *   },
   *   ...
   * }).build();
   *
   * if (result.extra?.reanimated === 3) {
   *   // handle build result for reanimated v3
   * }
   * ```
   */
  extra?: any;
}
interface ResolverConfig {
  /**
   * Dependency alias configuration
   */
  alias?: AliasConfig[];
  /**
   * Custom module protocol configuration
   */
  protocols?: ProtocolConfig;
}
interface AliasConfig extends Pick<esbuild$1.ResolveOptions, 'importer' | 'kind' | 'resolveDir' | 'with'> {
  /**
   * Replacement target module path
   */
  from: string;
  /**
   * Replacement module path or function that returns module path
   */
  to: ResolveResult | AliasResolver;
  /**
   * - `false`: (default) replace even if subpath exists (`^name(?:$|/)`)
   * - `true`: replace only if the target is exactly matched (`^name$`)
   *
   * ```js
   * const config = {
   *   alias: [
   *    { from: 'react-native', to: 'react-native-0.68' },
   *    { from: 'react', to: 'react-17', exact: true },
   *   ],
   * };
   *
   * // AS IS
   * import * as RN from 'react-native';
   * import 'react-native/Libraries/Core/InitializeCore';
   * import React from 'react';
   * import runtime from 'react/runtime';
   *
   * // TO BE
   * import * as RN from 'react-native-0.68';
   * import 'react-native-0.68/Libraries/Core/InitializeCore';
   * import React from 'react-17';
   * import runtime from 'react/runtime'; // exact
   * ```
   */
  exact?: boolean;
}
type ResolveResult = string | ResolveResultWithOptions;
interface ResolveResultWithOptions extends Omit<esbuild$1.ResolveOptions, 'pluginName' | 'pluginData'> {
  path: string;
}
type AliasResolver = (context: {
  args: esbuild$1.OnResolveArgs;
  resolve: esbuild$1.PluginBuild['resolve'];
}) => ResolveResult | Promise<ResolveResult>;
/**
 * Custom protocol resolve configuration
 *
 * This option configures to directly resolve and load modules referenced by the specified protocol
 *
 * ```ts
 * // AS-IS
 * import mod from 'custom-protocol:/path/to/module';
 *
 * // TO-BE
 * // `custom-protocol:/path/to/module` module is handled as follows
 * export default global.__import('/path/to/module');
 * ```
 *
 * Configuration example
 *
 * ```ts
 * {
 *   'custom-protocol': {
 *     resolve: (args) => args.path,
 *     load: (args) => {
 *       return { loader: 'ts', contents: `export default global.__import('${args.path}')` };
 *     },
 *   },
 * }
 * ```
 */
interface ProtocolConfig {
  [name: string]: {
    /**
     * Module path to resolve
     */
    resolve?: (args: esbuild$1.OnResolveArgs) => string | Promise<string>;
    /**
     * Return module code based on the resolved path
     */
    load: (args: esbuild$1.OnLoadArgs) => esbuild$1.OnLoadResult | Promise<esbuild$1.OnLoadResult>;
  };
}
interface TransformerConfig {
  transformSync?: TransformSync;
  transformAsync?: TransformAsync;
}
type TransformSync = (id: string, code: string) => string;
type TransformAsync = (id: string, code: string) => Promise<string>;
interface EsbuildConfig extends esbuild$1.BuildOptions {
  /**
   * Script path to inject at the entry point
   *
   * esbuild.inject option added script is not only injected into the entry-point module, but also into all modules.
   * entry-point module's top level only inject code.
   *
   * - injected only once at the top level of the entry-point module
   * - duplicate inject script is removed, reducing bundle size
   *
   * @see issue {@link https://github.com/evanw/esbuild/issues/475}
   */
  prelude?: string[];
}
interface SwcConfig {
  /**
   * Plugin binary(wasm) path, plugin configuration
   */
  plugins?: NonNullable<swc.JscConfig['experimental']>['plugins'];
}
interface BabelConfig {
  /**
   * List of rules for Babel transform processing
   * (option to skip Babel transform only when certain conditions are met)
   *
   * If all rules return `false`, Babel transform is skipped
   */
  conditions?: Array<(code: string, path: string) => boolean>;
  configFile?: string;
  presets?: string[];
  plugins?: (string | [string, any])[];
} //#endregion
//#region src/types/BuildResult.d.ts
type BuildResult = BuildSuccessResult | BuildFailureResult;
interface BuildSuccessResult extends esbuild.BuildResult {
  bundle: BundleData;
  outfile: BuildConfig['outfile'];
  sourcemapOutfile: NonNullable<BuildConfig['sourcemapOutfile']>;
  platform: BuildConfig['platform'];
  extra: BuildConfig['extra'];
  totalModuleCount: number;
  duration: number;
  size: number;
}
interface BuildFailureResult extends esbuild.BuildResult {
  platform: BuildConfig['platform'];
  extra: BuildConfig['extra'];
  duration: number;
}
interface BundleData {
  source: esbuild.OutputFile;
  sourcemap: esbuild.OutputFile;
}

//#endregion
//#region src/types/DevServerConfig.d.ts
type Middleware = FastifyPluginAsync | FastifyPluginCallback;
type MetroMiddleware = HandleFunction;
interface InspectorProxyConfig {
  delegate?: {
    /**
     * @param message CDP message from the connected device
     * @param socket `WebSocket` instance that connected to the device
     * @returns `true` if the message is handled, `false` otherwise
     */
    onDeviceMessage?: <DeviceMessage extends {
      method: string;
      params: Record<string, any>;
    }>(message: DeviceMessage, socket: ws.WebSocket) => boolean;
    /**
     * @param message CDP message from debugger
     * @param socket `WebSocket` instance that connected to debugger
     * @returns `true` if the message is handled, `false` otherwise
     */
    onDebuggerMessage?: <DebuggerMessage extends {
      method: string;
      params: Record<string, any>;
    }>(message: DebuggerMessage, socket: ws.WebSocket) => boolean;
  };
}
interface DevServerConfig {
  middlewares?: Middleware[];
  inspectorProxy?: InspectorProxyConfig;
}
interface MetroDevServerConfig {
  middlewares?: MetroMiddleware[];
  inspectorProxy?: InspectorProxyConfig;
}

//#endregion
//#region src/types/vendors/metro.d.ts
type Untyped = any;
interface PackageJson {
  readonly name?: string;
  readonly main?: string;
  readonly exports?: string | Untyped;
}
interface PackageInfo {
  readonly packageJson: PackageJson;
  readonly rootPath: string;
}
type ResolveAsset = (dirPath: string, assetName: string, extension: string) => string[] | undefined;
interface ResolutionContext {
  readonly assetExts: string[];
  readonly allowHaste: boolean;
  readonly customResolverOptions: Untyped;
  readonly disableHierarchicalLookup: boolean;
  readonly doesFileExist: Untyped;
  readonly extraNodeModules?: {
    [key: string]: string;
  };
  readonly getPackage: (packageJsonPath: string) => PackageJson | null;
  readonly getPackageForModule: (modulePath: string) => PackageInfo | null;
  readonly dependency?: any;
  readonly mainFields: string[];
  readonly originModulePath: string;
  readonly nodeModulesPaths: string[];
  readonly preferNativePlatform: boolean;
  readonly resolveAsset: ResolveAsset;
  readonly redirectModulePath: (modulePath: string) => string | false;
  readonly resolveHasteModule: (name: string) => string | undefined;
  readonly resolveHastePackage: (name: string) => string | undefined;
  readonly resolveRequest?: CustomResolver;
  readonly sourceExts: string[];
  readonly unstable_conditionsByPlatform: {
    [platform: string]: string[];
  };
  unstable_conditionNames: string[];
  unstable_enablePackageExports: boolean;
  unstable_getRealPath?: any;
  unstable_logWarning: (message: string) => void;
}
interface CustomResolutionContext extends ResolutionContext {
  readonly resolveRequest: CustomResolver;
}
type CustomResolver = (context: CustomResolutionContext, moduleName: string, platform: string | null) => any;
interface ResolverConfig$1 {
  assetExts: string[];
  assetResolutions: string[];
  blacklistRE?: RegExp | RegExp[];
  blockList: RegExp | RegExp[];
  dependencyExtractor?: string;
  disableHierarchicalLookup: boolean;
  extraNodeModules: {
    [name: string]: string;
  };
  emptyModulePath: string;
  enableGlobalPackages: boolean;
  hasteImplModulePath?: string;
  nodeModulesPaths: string[];
  platforms: string[];
  resolveRequest?: CustomResolver;
  resolverMainFields: string[];
  sourceExts: string[];
  unstable_enableSymlinks: boolean;
  unstable_conditionNames: string[];
  unstable_conditionsByPlatform: Readonly<{
    [platform: string]: string[];
  }>;
  unstable_enablePackageExports: boolean;
  useWatchman: boolean;
  requireCycleIgnorePatterns: ReadonlyArray<RegExp>;
}
interface BundleDetails {
  bundleType: string;
  dev: boolean;
  entryFile: string;
  minify: boolean;
  platform?: string;
  runtimeBytecodeVersion?: number;
}
type WatcherStatus = {
  type: 'watchman_slow_command';
  timeElapsed: number;
  command: 'watch-project' | 'query';
} | {
  type: 'watchman_slow_command_complete';
  timeElapsed: number;
  command: 'watch-project' | 'query';
} | {
  type: 'watchman_warning';
  warning: unknown;
  command: 'watch-project' | 'query';
};
type HealthCheckResult = {
  type: 'error';
  timeout: number;
  error: Error;
  watcher: string | null;
} | {
  type: 'success';
  timeout: number;
  timeElapsed: number;
  watcher: string | null;
} | {
  type: 'timeout';
  timeout: number;
  watcher: string | null;
  pauseReason: string | null;
};
type ReportableEvent = {
  port: number;
  hasReducedPerformance: boolean;
  type: 'initialize_started';
} | {
  type: 'initialize_failed';
  port: number;
  error: Error;
} | {
  type: 'initialize_done';
  port: number;
} | {
  buildID: string;
  type: 'bundle_build_done';
} | {
  buildID: string;
  type: 'bundle_build_failed';
} | {
  type: 'bundle_save_log';
  message: string;
} | {
  buildID: string;
  bundleDetails: BundleDetails;
  isPrefetch?: boolean;
  type: 'bundle_build_started';
} | {
  error: Error;
  type: 'bundling_error';
} | {
  type: 'dep_graph_loading';
  hasReducedPerformance: boolean;
} | {
  type: 'dep_graph_loaded';
} | {
  buildID: string;
  type: 'bundle_transform_progressed';
  transformedFileCount: number;
  totalFileCount: number;
} | {
  type: 'cache_read_error';
  error: Error;
} | {
  type: 'cache_write_error';
  error: Error;
} | {
  type: 'transform_cache_reset';
} | {
  type: 'worker_stdout_chunk';
  chunk: string;
} | {
  type: 'worker_stderr_chunk';
  chunk: string;
} | {
  type: 'hmr_client_error';
  error: Error;
} | {
  type: 'client_log';
  level: 'trace' | 'info' | 'warn' | 'log' | 'group' | 'groupCollapsed' | 'groupEnd' | 'debug';
  data: Array<unknown>;
  mode: 'BRIDGE' | 'NOBRIDGE';
} | {
  type: 'resolver_warning';
  message: string;
} | {
  type: 'server_listening';
  port: number;
  address: string;
  family: string;
} | {
  type: 'transformer_load_started';
} | {
  type: 'transformer_load_done';
} | {
  type: 'transformer_load_failed';
  error: Error;
} | {
  type: 'watcher_health_check_result';
  result: HealthCheckResult;
} | {
  type: 'watcher_status';
  status: WatcherStatus;
};
interface MetroConfig {
  readonly watchFolders?: string[];
  readonly cacheStores?: any;
  readonly resolver?: Partial<ResolverConfig$1>;
  readonly server?: any;
  readonly serializer?: object & {
    getPolyfills?: () => string[];
  };
  readonly symbolicator?: any;
  readonly transformer?: any;
  readonly watcher?: any;
  readonly reporter?: {
    update: (event: ReportableEvent) => void;
  };
}

//#endregion
//#region src/types/MetroConfig.d.ts
interface AdditionalMetroConfig extends MetroConfig {
  /**
   * Partial support for some options only
   *
   * - `getPolyfills`
   */
  serializer?: MetroConfig['serializer'];
  /**
   * Partial support for some options only
   *
   * - `blockList`
   */
  resolver?: MetroConfig['resolver'];
  reporter?: MetroConfig['reporter'];
  babelConfig?: babel.TransformOptions;
  transformSync?: (id: string, code: string) => string;
}

//#endregion
//#region src/types/GranitePlugin.d.ts
interface GranitePluginConfig {
  entryFile: string;
  cwd: string;
  appName: string;
  outdir: string;
}
interface GranitePluginDevHandlerArgs extends GranitePluginConfig {
  host: string;
  port: number;
}
type GranitePluginPreHandlerArgs = GranitePluginConfig;
interface GranitePluginPostHandlerArgs extends GranitePluginConfig {
  buildResults: BuildResult[];
}
interface PluginContext {
  meta: any;
}
type GranitePluginDevPreHandler = (this: PluginContext, args: GranitePluginDevHandlerArgs) => void | Promise<void>;
type GranitePluginDevPostHandler = (this: PluginContext, args: GranitePluginDevHandlerArgs) => void | Promise<void>;
type GranitePluginBuildPreHandler = (this: PluginContext, args: GranitePluginPreHandlerArgs) => void | Promise<void>;
type GranitePluginBuildPostHandler = (this: PluginContext, args: GranitePluginPostHandlerArgs) => void | Promise<void>;
interface GranitePluginCore {
  /**
   * Plugin name
   */
  name: string;
  /**
   * Dev handler (granite dev command)
   */
  dev?: {
    order: 'pre';
    handler: GranitePluginDevPreHandler;
  } | {
    order: 'post';
    handler: GranitePluginDevPostHandler;
  };
  /**
   * Build handler (granite build command)
   */
  build?: {
    order: 'pre';
    handler: GranitePluginBuildPreHandler;
  } | {
    order: 'post';
    handler: GranitePluginBuildPostHandler;
  };
  /**
   * Plugin config
   */
  config?: PluginConfig;
}
type PluginConfig = StaticPluginConfig | DynamicPluginConfig;
type StaticPluginConfig = Omit<PluginBuildConfig, 'platform' | 'outfile'> & {
  devServer?: DevServerConfig;
  metro?: PluginMetroConfig;
};
type DynamicPluginConfig = (() => StaticPluginConfig) | (() => Promise<StaticPluginConfig>);
type PluginMetroConfig = Omit<ResolvedMetroConfig, 'babelConfig' | 'transformSync'>;
type ResolvedPluginConfig = Omit<StaticPluginConfig, 'metro'> & {
  metro?: ResolvedMetroConfig;
};
type ResolvedMetroConfig = AdditionalMetroConfig & MetroDevServerConfig;
type PluginResolvable = GranitePlugin | GranitePluginCore | Promise<GranitePlugin> | Promise<GranitePluginCore>;
type PluginInput = PluginResolvable | PluginInput[];
type PluginBuildConfig = Omit<BuildConfig, 'platform' | 'entry' | 'outfile'>;
type GranitePlugin = GranitePluginCore | Promise<GranitePluginCore>;

//#endregion
//#region src/createContext.d.ts
declare function createContext(): PluginContext;

//#endregion
//#region src/utils/flattenPlugins.d.ts
declare const flattenPlugins: (plugin: PluginInput) => Promise<GranitePluginCore[]>;

//#endregion
//#region src/utils/resolvePlugins.d.ts
declare function resolvePlugins(plugins: PluginInput): Promise<{
  plugins: GranitePluginCore[];
  configs: (StaticPluginConfig | (() => StaticPluginConfig) | (() => Promise<StaticPluginConfig>))[];
  pluginHooks: {
    devServer: {
      preHandlers: GranitePluginDevPreHandler[];
      postHandlers: GranitePluginDevPostHandler[];
    };
    build: {
      preHandlers: GranitePluginBuildPreHandler[];
      postHandlers: GranitePluginBuildPostHandler[];
    };
  };
}>;

//#endregion
//#region src/utils/mergeConfig.d.ts
declare function mergeConfig(base: PluginConfig, ...configs: PluginConfig[]): Promise<StaticPluginConfig | undefined>;

//#endregion
//#region src/utils/mergeBuildConfigs.d.ts
declare function mergeBuildConfigs(baseConfig: BuildConfig, ...otherConfigs: Partial<BuildConfig>[]): BuildConfig;

//#endregion
//#region src/schema/pluginConfig.d.ts
declare const pluginConfigSchema: z.ZodObject<{
  cwd: z.ZodDefault<z.ZodString>;
  appName: z.ZodString;
  host: z.ZodOptional<z.ZodString>;
  scheme: z.ZodString;
  outdir: z.ZodDefault<z.ZodString>;
  entryFile: z.ZodDefault<z.ZodString>;
  build: z.ZodOptional<z.ZodCustom<PluginBuildConfig, PluginBuildConfig>>;
  devServer: z.ZodOptional<z.ZodCustom<DevServerConfig, DevServerConfig>>;
  metro: z.ZodOptional<z.ZodCustom<AdditionalMetroConfig & MetroDevServerConfig, AdditionalMetroConfig & MetroDevServerConfig>>;
  plugins: z.ZodCustom<PluginInput, PluginInput>;
}, z.core.$strip>;
type GraniteConfig = z.input<typeof pluginConfigSchema>;
type ParsedGraniteConfig = z.output<typeof pluginConfigSchema>;
type CompleteGraniteConfig = {
  cwd: ParsedGraniteConfig['cwd'];
  appName: ParsedGraniteConfig['appName'];
  entryFile: ParsedGraniteConfig['entryFile'];
  outdir: ParsedGraniteConfig['outdir'];
  pluginHooks: GranitePluginHooks;
  pluginConfigs: PluginConfig[];
};
interface GranitePluginHooks {
  devServer: {
    preHandlers: GranitePluginDevPreHandler[];
    postHandlers: GranitePluginDevPostHandler[];
  };
  build: {
    preHandlers: GranitePluginBuildPreHandler[];
    postHandlers: GranitePluginBuildPostHandler[];
  };
}

//#endregion
//#region src/utils/createPluginHooksDriver.d.ts
declare function createPluginHooksDriver(config: CompleteGraniteConfig): {
  devServer: {
    pre: (args: Omit<GranitePluginDevHandlerArgs, keyof GranitePluginConfig>) => Promise<void>;
    post: (args: Omit<GranitePluginDevHandlerArgs, keyof GranitePluginConfig>) => Promise<void>;
  };
  build: {
    pre: () => Promise<void>;
    post: (args: Omit<GranitePluginPostHandlerArgs, keyof GranitePluginConfig>) => Promise<void>;
  };
};
declare function createPluginContext(): PluginContext;

//#endregion
//#region src/utils/buildResult.d.ts
declare function isBuildSuccess(result: BuildResult): result is BuildSuccessResult;
declare function isBuildFailure(result: BuildResult): result is BuildFailureResult;

//#endregion
//#region src/utils/resolveConfig.d.ts
declare function resolveConfig(config: CompleteGraniteConfig): Promise<ResolvedPluginConfig>;

//#endregion
//#region src/config/defineConfig.d.ts
/**
 * @public
 * @category Configuration
 * @name defineConfig
 * @description
 * Configures your Granite application by defining key settings in `granite.config.ts`.
 *
 * The configuration lets you specify:
 * - How users will access your app through a URL scheme (e.g. `granite://`)
 * - Your app's unique name that appears in the URL (e.g. `granite://my-service`)
 * - Build settings for bundlers like ESBuild and Metro
 * - Code transformation settings through Babel
 * - Additional functionality through Granite plugins
 *
 * @param config - Configuration options
 * @param config.cwd - Working directory for build process (defaults to process.cwd())
 * @param config.appName - Your app's unique identifier
 * @param config.host - Host name for your app (e.g. 'scheme://host/app-name')
 * @param config.scheme - URL scheme for launching your app (e.g. 'granite')
 * @param config.outdir - Where to output build files (defaults to 'dist')
 * @param config.entryFile - Your app's entry point (defaults to './src/_app.tsx')
 * @param config.build - Customize build settings
 * @param config.metro - Configure Metro bundler settings
 * @param config.devServer - Configure Mpack dev server settings
 * @param config.plugins - Granite plugins to enhance functionality
 * @returns The processed configuration
 *
 * @example
 * Here's a basic configuration that:
 * - Makes your app accessible via the `granite://` scheme
 * - Names your service "my-app" so it's reachable at `granite://my-app`
 * - Uses the Hermes plugin to optimize JavaScript bundles into bytecode
 *
 * ```ts
 * import { defineConfig } from '@granite-js/react-native/config';
 * import { hermes } from '@granite-js/plugin-hermes';
 *
 * export default defineConfig({
 *   // The name of your microservice
 *   appName: 'my-app',
 *   // (Optional) The host name for your app (e.g. 'scheme://host/app-name')
 *   host: 'super',
 *   // The URL scheme for deep linking
 *   scheme: 'granite',
 *   // Entry file path
 *   entryFile: 'index.ts',
 *   // Array of plugins to use
 *   plugins: [hermes()],
 * });
 * ```
 */
declare const defineConfig: (config: GraniteConfig) => Promise<CompleteGraniteConfig>;

//#endregion
//#region src/config/loadConfig.d.ts
interface LoadConfigOptions {
  /**
   * Root directory to search for the config file.
   *
   * Defaults to project root
   */
  root?: string;
  /**
   * Exact path to the config file.
   *
   * If provided, the config file will be loaded from the given path.
   * Otherwise, the config file will be searched for in the root directory.
   */
  configFile?: string;
}
declare const loadConfig: (options?: LoadConfigOptions) => Promise<CompleteGraniteConfig>;

//#endregion
export { AdditionalMetroConfig, AliasConfig, AliasResolver, BabelConfig, BuildConfig, BuildFailureResult, BuildResult, BuildSuccessResult, BundleData, CompleteGraniteConfig, DevServerConfig, DynamicPluginConfig, EsbuildConfig, GraniteConfig, GranitePlugin, GranitePluginBuildPostHandler, GranitePluginBuildPreHandler, GranitePluginConfig, GranitePluginCore, GranitePluginDevHandlerArgs, GranitePluginDevPostHandler, GranitePluginDevPreHandler, GranitePluginHooks, GranitePluginPostHandlerArgs, GranitePluginPreHandlerArgs, InspectorProxyConfig, MetroDevServerConfig, MetroMiddleware, Middleware, ParsedGraniteConfig, PluginBuildConfig, PluginConfig, PluginContext, PluginInput, PluginMetroConfig, PluginResolvable, ProtocolConfig, ResolveResult, ResolveResultWithOptions, ResolvedMetroConfig, ResolvedPluginConfig, ResolverConfig, StaticPluginConfig, SwcConfig, TransformAsync, TransformSync, TransformerConfig, createContext, createPluginContext, createPluginHooksDriver, defineConfig, flattenPlugins, isBuildFailure, isBuildSuccess, loadConfig, mergeBuildConfigs, mergeConfig, pluginConfigSchema, resolveConfig, resolvePlugins };