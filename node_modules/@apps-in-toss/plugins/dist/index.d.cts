import { GranitePluginCore } from '@granite-js/plugin-core';
import typia, { tags } from 'typia';

type PermissionReadWrite = 'read' | 'write';
type PermissionAccess = 'access';
type ClipboardPermission = {
    name: 'clipboard';
    access: PermissionReadWrite;
};
type GeolocationPermission = {
    name: 'geolocation';
    access: PermissionAccess;
};
type ContactsPermission = {
    name: 'contacts';
    access: PermissionReadWrite;
};
type PhotosPermission = {
    name: 'photos';
    access: PermissionReadWrite;
};
type CameraPermission = {
    name: 'camera';
    access: PermissionAccess;
};
type Permission = ClipboardPermission | GeolocationPermission | ContactsPermission | PhotosPermission | CameraPermission;
type AppManifest = {
    appName: string;
    permissions: Permission[];
    _metadata: {
        bundleFiles: string[];
        deploymentId: string & tags.Format<'uuid'>;
    };
};
type Icon = {
    source: {
        uri: string;
    };
    name?: never;
} | {
    name: string;
    source?: never;
};
interface InitialAccessoryButton {
    id: string;
    title: string;
    icon: Icon;
}
declare const validateAppManifest: (input: unknown) => typia.IValidation<AppManifest>;
interface AppsInTossPluginOptions {
    appType?: 'general' | 'game';
    brand: {
        displayName: string;
        primaryColor: string;
        icon: string;
        bridgeColorMode: BridgeTheme;
    };
    permissions: AppManifest['permissions'];
    navigationBar?: {
        withBackButton?: boolean;
        withHomeButton?: boolean;
        initialAccessoryButton?: InitialAccessoryButton;
    };
}
/**
 * - `basic`: 기본 테마 (흰 배경)
 * - `inverted`: 반전 테마 (검은 배경)
 */
type BridgeTheme = 'basic' | 'inverted';
declare const validateAppInTossPluginOptions: (input: unknown) => typia.IValidation<AppsInTossPluginOptions>;

declare function withAppsInTossCommon(plugins: (GranitePluginCore | Promise<GranitePluginCore>)[], options: AppsInTossPluginOptions & {
    root: string;
    deploymentId: string;
    reactNativeBasePath?: string;
    exposePath: string;
}): (GranitePluginCore | Promise<GranitePluginCore>)[];
declare function appsInToss(options: AppsInTossPluginOptions): (GranitePluginCore | Promise<GranitePluginCore>)[];

declare function analytics(): GranitePluginCore;

interface AppsInTossBuildMetadata {
    runtimeVersion: string;
    deploymentId: string;
    bundleFiles: string[];
    packageJson: {
        dependencies: Record<string, string>;
        devDependencies: Record<string, string>;
    };
}

type BuildResult = {
    jsFile: string;
    platform: 'ios' | 'android';
};
interface CreateArtifactOptions {
    bundleFiles: {
        path: string;
        platform: 'ios' | 'android';
    }[];
    reactNativeVersion: string;
    appJsonPath: string;
    outfile: string;
    deploymentId: AppsInTossBuildMetadata['deploymentId'];
    packageJson: AppsInTossBuildMetadata['packageJson'];
    additionalFilesToZip?: {
        path: string;
        name: string;
    }[];
}
declare function validateZip(zipPath: string): Promise<void>;
declare function createArtifact(options: CreateArtifactOptions): Promise<string>;

declare function setupRuntimeSetupScript(config: Pick<AppsInTossPluginOptions, 'appType' | 'brand' | 'navigationBar'> & {
    deploymentId: string;
}): {
    contents: string;
    path: string;
};
declare function setupHostRuntimeSetupScript(metadata: {
    deploymentId: string;
    environment: 'live' | 'alpha';
}): {
    contents: string;
    path: string;
};
declare function getRuntimeSetupScript<T extends object>(metadata: T, identifier: string): string;

declare function collectDependencyVersions(rootDir: string): Promise<{
    dependencies: Record<string, string>;
    devDependencies: Record<string, string>;
}>;

declare function appsInTossAppJson(options: Pick<AppsInTossPluginOptions, 'permissions'>): Promise<GranitePluginCore>;

declare function appsInTossCreateArtifact(deploymentId: string): GranitePluginCore;

declare function appsInTossEsbuildConfig(envScript: string): GranitePluginCore;
declare function appsInTossMetroConfig(envScriptPath: string): GranitePluginCore;

/**
 * React Native 번들을 포함하는 환경(Shared, 혹은 Metro single bundle) 내에서 React Native 모듈을 평가하기 때문에,
 * `NativeModules` 접근 이전에 `nativeModuleProxy`를 오버라이드 할 수 있음.
 */
declare const nativeModuleProxyContent = "\n(function () {\n  global.nativeModuleProxy = new Proxy(global.nativeModuleProxy, {\n    get: function (target, name) {\n      if (name === 'GraniteModule') {\n        return target['BedrockModule'] || target[name];\n      }\n\n      if (name === 'GraniteCoreModule') {\n        return target['BedrockCoreModule'] || target[name];\n      }\n\n      return target[name];\n    }\n  });\n\n  global.__nativeModuleProxyConfigured = true;\n})(\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof global !== 'undefined'\n    ? global\n    : typeof window !== 'undefined'\n    ? window\n    : this\n);\n";
/**
 * Remote 번들에서는 Host 번들에서 React Native를 참조하므로, `NativeModules` 평가 이전에 `nativeModuleProxy`를 오버라이드 할 수 없다.
 * 따라서 React Native 모듈 객체에 대한 프록시를 생성하여 `TurboModuleRegistry` 동작을 오버라이드 하도록 한다.
 *
 * 단, `nativeModuleProxy` 오버라이드 코드가 구성된 런타임인 경우 해당 과정은 건너뛰도록 분기 처리한다.
 */
declare const reactNativeModuleProxyContent = "\n(function (global) {\n  if (global.__nativeModuleProxyConfigured) {\n    return;\n  }\n\n  function getCustomTurboModuleRegistry(registry) {\n    var remappedModules = {\n      'GraniteModule': 'BedrockModule',\n      'GraniteCoreModule': 'BedrockCoreModule',\n    };\n\n    return {\n      get: function (name) {\n        var mod;\n        var remappedName = remappedModules[name];\n\n        if (remappedName) {\n          mod = registry.get(remappedName);\n        }\n\n        return mod || registry.get(name);\n      },\n      getEnforcing: function (name) {\n        var mod;\n        var remappedName = remappedModules[name];\n\n        if (remappedName) {\n          mod = registry.get(remappedName);\n        }\n\n        return mod || registry.getEnforcing(name);\n      }\n    };\n  }\n\n  function createReactNativeProxy(reactNative) {\n    return new Proxy(reactNative, {\n      get: function (target, name) {\n        var origin = target[name];\n        return name === 'TurboModuleRegistry' ? getCustomTurboModuleRegistry(origin) : origin;\n      }\n    });\n  }\n\n  var reactNative;\n\n  if (typeof global.__MICRO_FRONTEND__ !== 'undefined') {\n    var mod = global.__MICRO_FRONTEND__.__SHARED__['react-native'];\n    reactNative = mod && mod.get();\n  }\n\n  if (reactNative == null && typeof __bedrock_require__ === 'function') {\n    reactNative = global.__bedrock_require__('react-native');\n  }\n\n  if (reactNative == null) {\n    throw new Error('cannot get react-native in the global registry');\n  }\n\n  global.__reactNativeProxy = createReactNativeProxy(reactNative);\n  global.__MICRO_FRONTEND__.__SHARED__['react-native'] = {\n    get: function () {\n      return global.__reactNativeProxy;\n    },\n    loaded: true,\n  };\n})(\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof global !== 'undefined'\n    ? global\n    : typeof window !== 'undefined'\n    ? window\n    : this\n);\n";
declare function bedrockCompat({ isHost }: {
    isHost: boolean;
}): GranitePluginCore;

declare function appsInTossDevServer(options: Pick<AppsInTossPluginOptions, 'permissions'>): GranitePluginCore;

declare function appsInTossPostNotice(): GranitePluginCore;

declare function requireMicroFrontendRuntime(): GranitePluginCore;

export { type AppManifest, type AppsInTossPluginOptions, type BridgeTheme, type BuildResult, type CreateArtifactOptions, type InitialAccessoryButton, type Permission, analytics, appsInToss, appsInTossAppJson, appsInTossCreateArtifact, appsInTossDevServer, appsInTossEsbuildConfig, appsInTossMetroConfig, appsInTossPostNotice, bedrockCompat, collectDependencyVersions, createArtifact, getRuntimeSetupScript, nativeModuleProxyContent, reactNativeModuleProxyContent, requireMicroFrontendRuntime, setupHostRuntimeSetupScript, setupRuntimeSetupScript, validateAppInTossPluginOptions, validateAppManifest, validateZip, withAppsInTossCommon };
