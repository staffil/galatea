"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../.yarn/__virtual__/tsup-virtual-5261887034/0/cache/tsup-npm-8.4.0-f78d2622c9-c6636ffd6a.zip/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl, importMetaUrl;
var init_cjs_shims = __esm({
  "../../.yarn/__virtual__/tsup-virtual-5261887034/0/cache/tsup-npm-8.4.0-f78d2622c9-c6636ffd6a.zip/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
    getImportMetaUrl = () => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
    importMetaUrl = /* @__PURE__ */ getImportMetaUrl();
  }
});

// ../../.yarn/__virtual__/typia-virtual-93fdc6e779/0/cache/typia-npm-8.0.4-b2444b63f3-1028a8a121.zip/node_modules/typia/lib/internal/_isFormatUuid.js
var require_isFormatUuid = __commonJS({
  "../../.yarn/__virtual__/typia-virtual-93fdc6e779/0/cache/typia-npm-8.0.4-b2444b63f3-1028a8a121.zip/node_modules/typia/lib/internal/_isFormatUuid.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._isFormatUuid = void 0;
    var _isFormatUuid2 = (str) => PATTERN.test(str);
    exports2._isFormatUuid = _isFormatUuid2;
    var PATTERN = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  }
});

// ../../.yarn/__virtual__/typia-virtual-93fdc6e779/0/cache/typia-npm-8.0.4-b2444b63f3-1028a8a121.zip/node_modules/typia/lib/internal/_validateReport.js
var require_validateReport = __commonJS({
  "../../.yarn/__virtual__/typia-virtual-93fdc6e779/0/cache/typia-npm-8.0.4-b2444b63f3-1028a8a121.zip/node_modules/typia/lib/internal/_validateReport.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._validateReport = void 0;
    var _validateReport2 = (array) => {
      const reportable = (path9) => {
        if (array.length === 0)
          return true;
        const last = array[array.length - 1].path;
        return path9.length > last.length || last.substring(0, path9.length) !== path9;
      };
      return (exceptable, error) => {
        if (exceptable && reportable(error.path))
          array.push(error);
        return false;
      };
    };
    exports2._validateReport = _validateReport2;
  }
});

// src/internal.ts
var internal_exports = {};
__export(internal_exports, {
  appsInTossHost: () => appsInTossHost
});
module.exports = __toCommonJS(internal_exports);
init_cjs_shims();

// src/appsInTossHost.ts
init_cjs_shims();
var import_plugin_micro_frontend = require("@granite-js/plugin-micro-frontend");
var import_plugin_sentry = require("@granite-js/plugin-sentry");

// src/constants.ts
init_cjs_shims();
var REACT_NATIVE_VERSION = "0.72.6";
var APP_MANIFEST_NAME = "app.json";
var MICRO_FRONTEND_HOST_NAME = "apps-in-toss-host";
var HOST_CONTEXT_IDENTIFIER = "__appsInTossHost";
var SHRED_PACKAGES = [
  "@react-native-community/blur",
  "@react-navigation/native",
  "@react-navigation/native-stack",
  "@shopify/flash-list",
  "lottie-react-native",
  "react-native-safe-area-context",
  "react-native-screens",
  "react-native-fast-image",
  "react-native-svg",
  "react-native-gesture-handler",
  "react-native",
  "react",
  "react-native-video",
  "react-native-webview"
];

// src/plugins/index.ts
init_cjs_shims();

// src/plugins/appJson.ts
init_cjs_shims();
var import_node_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var import_utils = require("@granite-js/utils");
async function appsInTossAppJson(options) {
  const packageRoot = (0, import_utils.getPackageRoot)();
  const handleAppJson = async (appName) => {
    const appJsonPath = import_path.default.join(packageRoot, ".granite", APP_MANIFEST_NAME);
    const appJsonObject = {
      appName,
      permissions: options.permissions
    };
    await import_node_fs.default.promises.mkdir(import_path.default.dirname(appJsonPath), { recursive: true });
    try {
      const existingAppJson = await import_node_fs.default.promises.readFile(appJsonPath, "utf8");
      const existingAppJsonObject = JSON.parse(existingAppJson);
      Object.assign(appJsonObject, existingAppJsonObject, {
        appName,
        permissions: appJsonObject.permissions
      });
    } catch {
    }
    await import_node_fs.default.promises.writeFile(appJsonPath, JSON.stringify(appJsonObject, null, 2), "utf8");
  };
  return {
    name: "apps-in-toss:app-json",
    dev: {
      order: "pre",
      handler: async ({ appName }) => {
        handleAppJson(appName);
      }
    },
    build: {
      order: "pre",
      handler: async ({ appName }) => {
        handleAppJson(appName);
      }
    }
  };
}

// src/plugins/artifact.ts
init_cjs_shims();
var import_path3 = __toESM(require("path"), 1);
var import_plugin_core = require("@granite-js/plugin-core");
var import_utils4 = require("@granite-js/utils");
var import_picocolors2 = __toESM(require("picocolors"), 1);

// src/log.ts
init_cjs_shims();
var import_picocolors = __toESM(require("picocolors"), 1);
var TAG = import_picocolors.default.bold(import_picocolors.default.cyan("[AppsInToss]"));
function log(...args) {
  console.log(TAG, ...args);
}

// src/utils/collectDependencyVersions.ts
init_cjs_shims();
var fs2 = __toESM(require("fs/promises"), 1);
var path2 = __toESM(require("path"), 1);
var esbuild = __toESM(require("esbuild"), 1);
async function collectDependencyVersions(rootDir) {
  const packageJsonPath = path2.join(rootDir, "package.json");
  const packageJson = JSON.parse(await fs2.readFile(packageJsonPath, "utf8"));
  const [dependencies, devDependencies] = await Promise.all([
    resolvePackageVersions(rootDir, Object.keys(packageJson.dependencies)),
    resolvePackageVersions(rootDir, Object.keys(packageJson.devDependencies))
  ]);
  return { dependencies, devDependencies };
}
async function resolvePackageVersions(rootDir, packageNames) {
  const results = {};
  await esbuild.build({
    stdin: { contents: createVirtualEntry(packageNames) },
    bundle: true,
    write: false,
    logLevel: "silent",
    plugins: [
      {
        name: "collect-package-version",
        setup(build2) {
          const RESOLVING = Symbol();
          build2.onResolve({ filter: /.*/ }, async (args) => {
            if (args.pluginData === RESOLVING) {
              return null;
            }
            const resolveOptions = {
              importer: args.importer,
              kind: args.kind,
              resolveDir: rootDir,
              pluginData: RESOLVING
            };
            let result = await build2.resolve(path2.join(args.path, "package.json"), resolveOptions);
            if (result.errors.length) {
              result = await build2.resolve(args.path, resolveOptions);
            }
            if (result.errors.length) {
              return result;
            }
            const packageName = args.path;
            const packagePath = extractPackagePath(result.path, packageName);
            if (packagePath) {
              results[packageName] = await getPackageVersion(packagePath);
            }
            return result;
          });
          build2.onLoad({ filter: /.*/ }, () => ({ contents: "// empty source" }));
        }
      }
    ]
  });
  return results;
}
function createVirtualEntry(packageNames) {
  return packageNames.map((packageName) => `import '${packageName}';`).join("\n");
}
function extractPackagePath(path9, packageName) {
  const normalizedPath = normalizePath(path9);
  if (normalizedPath.endsWith("/package.json")) {
    return normalizedPath.replace(/\/package\.json$/, "");
  }
  const match = normalizedPath.match(new RegExp(`(.*?node_modules/${packageName})/.*$`));
  if (match) {
    return match[1];
  }
  throw new Error(`Failed to extract path: ${packageName}`);
}
function normalizePath(path9) {
  return path9.replace(/\\/g, "/");
}
async function getPackageVersion(packagePath) {
  const packageJson = JSON.parse(await fs2.readFile(path2.join(packagePath, "package.json"), "utf-8"));
  return packageJson.version;
}

// src/utils/createArtifact.ts
init_cjs_shims();
var import_path2 = __toESM(require("path"), 1);
var import_utils3 = require("@granite-js/utils");

// src/utils/compressToZip.ts
init_cjs_shims();
var fs3 = __toESM(require("fs"), 1);
var path3 = __toESM(require("path"), 1);
var import_archiver = __toESM(require("archiver"), 1);
async function compressToZip(config) {
  const { files, outfile } = config;
  return new Promise((resolve, reject) => {
    const outputStream = fs3.createWriteStream(outfile);
    const archive = (0, import_archiver.default)("zip", { zlib: { level: 9 } });
    outputStream.on("close", () => resolve(outfile));
    outputStream.on("error", (error) => reject(error));
    archive.on("error", (error) => reject(error)).pipe(outputStream);
    files.forEach(({ path: filePath, name }) => {
      const fileName = name ?? path3.basename(filePath);
      archive.append(fs3.createReadStream(filePath), { name: fileName });
    });
    archive.finalize();
  });
}

// src/utils/updateAppJsonMetadata.ts
init_cjs_shims();
var fs4 = __toESM(require("fs/promises"), 1);
var path4 = __toESM(require("path"), 1);
var import_utils2 = require("@granite-js/utils");
async function resolveAppManifestPath() {
  const cwd = (0, import_utils2.getPackageRoot)();
  const appManifestPath = path4.join(cwd, ".granite", APP_MANIFEST_NAME);
  await fs4.access(appManifestPath, fs4.constants.F_OK);
  return appManifestPath;
}
async function readAppJson(appJsonPath) {
  const appJson = await fs4.readFile(appJsonPath, "utf8");
  return JSON.parse(appJson);
}
async function writeAppJson(appJsonPath, content) {
  await fs4.writeFile(appJsonPath, JSON.stringify(content));
}
async function updateAppJsonMetadata(metadata) {
  const appJsonPath = await resolveAppManifestPath();
  const appJson = await readAppJson(appJsonPath);
  await writeAppJson(appJsonPath, {
    ...appJson,
    _metadata: metadata
  });
}

// src/types.ts
init_cjs_shims();
var __typia_transform__isFormatUuid = __toESM(require_isFormatUuid(), 1);
var __typia_transform__validateReport = __toESM(require_validateReport(), 1);
var validateAppManifest = /* @__PURE__ */ (() => {
  const _io0 = (input) => "string" === typeof input.appName && (Array.isArray(input.permissions) && input.permissions.every((elem) => "object" === typeof elem && null !== elem && _iu0(elem))) && ("object" === typeof input._metadata && null !== input._metadata && _io6(input._metadata));
  const _io1 = (input) => "clipboard" === input.name && ("read" === input.access || "write" === input.access);
  const _io2 = (input) => "geolocation" === input.name && "access" === input.access;
  const _io3 = (input) => "contacts" === input.name && ("read" === input.access || "write" === input.access);
  const _io4 = (input) => "photos" === input.name && ("read" === input.access || "write" === input.access);
  const _io5 = (input) => "camera" === input.name && "access" === input.access;
  const _io6 = (input) => Array.isArray(input.bundleFiles) && input.bundleFiles.every((elem) => "string" === typeof elem) && ("string" === typeof input.deploymentId && __typia_transform__isFormatUuid._isFormatUuid(input.deploymentId));
  const _iu0 = (input) => (() => {
    if ("camera" === input.name)
      return _io5(input);
    else if ("photos" === input.name)
      return _io4(input);
    else if ("contacts" === input.name)
      return _io3(input);
    else if ("geolocation" === input.name)
      return _io2(input);
    else if ("clipboard" === input.name)
      return _io1(input);
    else
      return false;
  })();
  const _vo0 = (input, _path, _exceptionable = true) => ["string" === typeof input.appName || _report(_exceptionable, {
    path: _path + ".appName",
    expected: "string",
    value: input.appName
  }), (Array.isArray(input.permissions) || _report(_exceptionable, {
    path: _path + ".permissions",
    expected: "Array<Permission>",
    value: input.permissions
  })) && input.permissions.map((elem, _index3) => ("object" === typeof elem && null !== elem || _report(_exceptionable, {
    path: _path + ".permissions[" + _index3 + "]",
    expected: "(CameraPermission | ClipboardPermission | ContactsPermission | GeolocationPermission | PhotosPermission)",
    value: elem
  })) && _vu0(elem, _path + ".permissions[" + _index3 + "]", _exceptionable) || _report(_exceptionable, {
    path: _path + ".permissions[" + _index3 + "]",
    expected: "(CameraPermission | ClipboardPermission | ContactsPermission | GeolocationPermission | PhotosPermission)",
    value: elem
  })).every((flag) => flag) || _report(_exceptionable, {
    path: _path + ".permissions",
    expected: "Array<Permission>",
    value: input.permissions
  }), ("object" === typeof input._metadata && null !== input._metadata || _report(_exceptionable, {
    path: _path + "._metadata",
    expected: "__type",
    value: input._metadata
  })) && _vo6(input._metadata, _path + "._metadata", _exceptionable) || _report(_exceptionable, {
    path: _path + "._metadata",
    expected: "__type",
    value: input._metadata
  })].every((flag) => flag);
  const _vo1 = (input, _path, _exceptionable = true) => ["clipboard" === input.name || _report(_exceptionable, {
    path: _path + ".name",
    expected: '"clipboard"',
    value: input.name
  }), "read" === input.access || "write" === input.access || _report(_exceptionable, {
    path: _path + ".access",
    expected: '("read" | "write")',
    value: input.access
  })].every((flag) => flag);
  const _vo2 = (input, _path, _exceptionable = true) => ["geolocation" === input.name || _report(_exceptionable, {
    path: _path + ".name",
    expected: '"geolocation"',
    value: input.name
  }), "access" === input.access || _report(_exceptionable, {
    path: _path + ".access",
    expected: '"access"',
    value: input.access
  })].every((flag) => flag);
  const _vo3 = (input, _path, _exceptionable = true) => ["contacts" === input.name || _report(_exceptionable, {
    path: _path + ".name",
    expected: '"contacts"',
    value: input.name
  }), "read" === input.access || "write" === input.access || _report(_exceptionable, {
    path: _path + ".access",
    expected: '("read" | "write")',
    value: input.access
  })].every((flag) => flag);
  const _vo4 = (input, _path, _exceptionable = true) => ["photos" === input.name || _report(_exceptionable, {
    path: _path + ".name",
    expected: '"photos"',
    value: input.name
  }), "read" === input.access || "write" === input.access || _report(_exceptionable, {
    path: _path + ".access",
    expected: '("read" | "write")',
    value: input.access
  })].every((flag) => flag);
  const _vo5 = (input, _path, _exceptionable = true) => ["camera" === input.name || _report(_exceptionable, {
    path: _path + ".name",
    expected: '"camera"',
    value: input.name
  }), "access" === input.access || _report(_exceptionable, {
    path: _path + ".access",
    expected: '"access"',
    value: input.access
  })].every((flag) => flag);
  const _vo6 = (input, _path, _exceptionable = true) => [(Array.isArray(input.bundleFiles) || _report(_exceptionable, {
    path: _path + ".bundleFiles",
    expected: "Array<string>",
    value: input.bundleFiles
  })) && input.bundleFiles.map((elem, _index4) => "string" === typeof elem || _report(_exceptionable, {
    path: _path + ".bundleFiles[" + _index4 + "]",
    expected: "string",
    value: elem
  })).every((flag) => flag) || _report(_exceptionable, {
    path: _path + ".bundleFiles",
    expected: "Array<string>",
    value: input.bundleFiles
  }), "string" === typeof input.deploymentId && (__typia_transform__isFormatUuid._isFormatUuid(input.deploymentId) || _report(_exceptionable, {
    path: _path + ".deploymentId",
    expected: 'string & Format<"uuid">',
    value: input.deploymentId
  })) || _report(_exceptionable, {
    path: _path + ".deploymentId",
    expected: '(string & Format<"uuid">)',
    value: input.deploymentId
  })].every((flag) => flag);
  const _vu0 = (input, _path, _exceptionable = true) => (() => {
    if ("camera" === input.name)
      return _vo5(input, _path, _exceptionable);
    else if ("photos" === input.name)
      return _vo4(input, _path, _exceptionable);
    else if ("contacts" === input.name)
      return _vo3(input, _path, _exceptionable);
    else if ("geolocation" === input.name)
      return _vo2(input, _path, _exceptionable);
    else if ("clipboard" === input.name)
      return _vo1(input, _path, _exceptionable);
    else
      return _report(_exceptionable, {
        path: _path,
        expected: "(CameraPermission | PhotosPermission | ContactsPermission | GeolocationPermission | ClipboardPermission)",
        value: input
      });
  })();
  const __is = (input) => "object" === typeof input && null !== input && _io0(input);
  let errors;
  let _report;
  return (input) => {
    if (false === __is(input)) {
      errors = [];
      _report = __typia_transform__validateReport._validateReport(errors);
      ((input2, _path, _exceptionable = true) => ("object" === typeof input2 && null !== input2 || _report(true, {
        path: _path + "",
        expected: "AppManifest",
        value: input2
      })) && _vo0(input2, _path + "", true) || _report(true, {
        path: _path + "",
        expected: "AppManifest",
        value: input2
      }))(input, "$input", true);
      const success = 0 === errors.length;
      return success ? {
        success,
        data: input
      } : {
        success,
        errors,
        data: input
      };
    }
    return {
      success: true,
      data: input
    };
  };
})();

// src/utils/createArtifact.ts
async function validateZip(zipPath) {
  const appJsonString = await (0, import_utils3.readZipContent)(zipPath, "app.json");
  const appJson = JSON.parse(appJsonString);
  const validated = validateAppManifest(appJson);
  if (!validated.success) {
    throw new Error("granite.config.ts \uAC12\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.");
  }
}
async function createArtifact(options) {
  const { bundleFiles, outfile, appJsonPath, reactNativeVersion } = options;
  const namedBundleFiles = bundleFiles.map((bundle) => {
    const originalName = import_path2.default.basename(bundle.path);
    const extension = import_path2.default.extname(originalName);
    const runtime = reactNativeVersion.replace(new RegExp(/\./g), "_");
    return {
      path: bundle.path,
      // TODO: Use shared utils for sync file name specification with Lambda
      name: `bundle.${bundle.platform}.${runtime}${extension === ".map" ? `.js.map` : extension}`
    };
  });
  await updateAppJsonMetadata({
    runtimeVersion: reactNativeVersion,
    bundleFiles: namedBundleFiles.map(({ name }) => name),
    deploymentId: options.deploymentId,
    packageJson: options.packageJson
  });
  await compressToZip({
    files: [{ path: appJsonPath, name: "app.json" }, ...namedBundleFiles, ...options.additionalFilesToZip ?? []],
    outfile
  });
  await validateZip(outfile);
  return outfile;
}

// src/plugins/artifact.ts
function appsInTossCreateArtifact(deploymentId) {
  const packageRoot = (0, import_utils4.getPackageRoot)();
  return {
    name: "apps-in-toss:create-artifact",
    build: {
      order: "post",
      handler: async ({ buildResults, appName, cwd }) => {
        const buildFailed = buildResults.some(import_plugin_core.isBuildFailure);
        if (buildFailed) {
          throw new Error("\uBC88\uB4E4 \uBE4C\uB4DC \uC2E4\uD328");
        }
        log("\uC571 \uBE4C\uB4DC \uC911...");
        const { dependencies, devDependencies } = await collectDependencyVersions(cwd);
        const artifactOutfile = await createArtifact({
          reactNativeVersion: REACT_NATIVE_VERSION,
          deploymentId,
          packageJson: { dependencies, devDependencies },
          bundleFiles: buildResults.filter(import_plugin_core.isBuildSuccess).map(({ outfile, sourcemapOutfile, platform }) => [
            {
              path: outfile,
              platform
            },
            {
              path: sourcemapOutfile,
              platform
            }
          ]).flat(),
          outfile: import_path3.default.join(cwd, `${appName}.ait`),
          appJsonPath: import_path3.default.join(packageRoot, ".granite", APP_MANIFEST_NAME)
        });
        if (!artifactOutfile) {
          throw new Error("\uC544\uD2F0\uD329\uD2B8 \uC0DD\uC131\uC5D0 \uC2E4\uD328\uD588\uC5B4\uC694.");
        }
        const filename = import_path3.default.basename(artifactOutfile);
        log(`\u2705 ${import_picocolors2.default.green(`${filename}`)} \uBE4C\uB4DC \uC644\uB8CC`);
      }
    }
  };
}

// src/plugins/build.ts
init_cjs_shims();
function appsInTossEsbuildConfig(envScript) {
  return {
    name: "apps-in-toss:esbuild-config",
    config: {
      esbuild: {
        banner: {
          js: envScript
        }
      }
    }
  };
}
function appsInTossMetroConfig(envScriptPath) {
  return {
    name: "apps-in-toss:metro-config",
    config: {
      metro: {
        serializer: {
          getPolyfills: () => [envScriptPath]
        }
      }
    }
  };
}

// src/plugins/compat.ts
init_cjs_shims();
var import_fs = __toESM(require("fs"), 1);
var import_path4 = __toESM(require("path"), 1);
var import_utils5 = require("@granite-js/utils");
var nativeModuleProxyContent = `
(function () {
  global.nativeModuleProxy = new Proxy(global.nativeModuleProxy, {
    get: function (target, name) {
      if (name === 'GraniteModule') {
        return target['BedrockModule'] || target[name];
      }

      if (name === 'GraniteCoreModule') {
        return target['BedrockCoreModule'] || target[name];
      }

      return target[name];
    }
  });

  global.__nativeModuleProxyConfigured = true;
})(
  typeof globalThis !== 'undefined'
    ? globalThis
    : typeof global !== 'undefined'
    ? global
    : typeof window !== 'undefined'
    ? window
    : this
);
`;
var reactNativeModuleProxyContent = `
(function (global) {
  if (global.__nativeModuleProxyConfigured) {
    return;
  }

  function getCustomTurboModuleRegistry(registry) {
    var remappedModules = {
      'GraniteModule': 'BedrockModule',
      'GraniteCoreModule': 'BedrockCoreModule',
    };

    return {
      get: function (name) {
        var mod;
        var remappedName = remappedModules[name];

        if (remappedName) {
          mod = registry.get(remappedName);
        }

        return mod || registry.get(name);
      },
      getEnforcing: function (name) {
        var mod;
        var remappedName = remappedModules[name];

        if (remappedName) {
          mod = registry.get(remappedName);
        }

        return mod || registry.getEnforcing(name);
      }
    };
  }

  function createReactNativeProxy(reactNative) {
    return new Proxy(reactNative, {
      get: function (target, name) {
        var origin = target[name];
        return name === 'TurboModuleRegistry' ? getCustomTurboModuleRegistry(origin) : origin;
      }
    });
  }

  var reactNative;

  if (typeof global.__MICRO_FRONTEND__ !== 'undefined') {
    var mod = global.__MICRO_FRONTEND__.__SHARED__['react-native'];
    reactNative = mod && mod.get();
  }

  if (reactNative == null && typeof __bedrock_require__ === 'function') {
    reactNative = global.__bedrock_require__('react-native');
  }

  if (reactNative == null) {
    throw new Error('cannot get react-native in the global registry');
  }

  global.__reactNativeProxy = createReactNativeProxy(reactNative);
  global.__MICRO_FRONTEND__.__SHARED__['react-native'] = {
    get: function () {
      return global.__reactNativeProxy;
    },
    loaded: true,
  };
})(
  typeof globalThis !== 'undefined'
    ? globalThis
    : typeof global !== 'undefined'
    ? global
    : typeof window !== 'undefined'
    ? window
    : this
);
`;
function bedrockCompat({ isHost }) {
  const metroPolyfillContent = import_path4.default.join((0, import_utils5.getLocalTempDirectoryPath)((0, import_utils5.getPackageRoot)()), "metro-native-module-proxy.js");
  import_fs.default.writeFileSync(metroPolyfillContent, nativeModuleProxyContent);
  return {
    name: "bedrock-compat-plugin",
    config: {
      esbuild: {
        banner: {
          js: isHost ? nativeModuleProxyContent : reactNativeModuleProxyContent
        }
      },
      metro: {
        serializer: {
          getPolyfills: () => [metroPolyfillContent]
        }
      }
    }
  };
}

// src/plugins/devServer.ts
init_cjs_shims();

// src/utils/createServerPermissionsMiddleware.ts
init_cjs_shims();
function createServerPermissionsMiddleware(permissions) {
  const parsedPermissions = parsePermissions(permissions);
  return (req, res, next) => {
    if (req.method === "GET" && req.url === "/permissions") {
      res.writeHead(200, {
        "Content-Length": Buffer.byteLength(parsedPermissions),
        "Content-Type": "text/plain"
      }).end(parsedPermissions);
      return;
    }
    next();
  };
}
function parsePermissions(permissions) {
  const permissionMap = /* @__PURE__ */ new Map();
  for (const permission of permissions) {
    const { name, access: access2 } = permission;
    if (!permissionMap.has(name)) {
      permissionMap.set(name, /* @__PURE__ */ new Set());
    }
    let accessValue = null;
    switch (access2) {
      case "read":
        accessValue = "r";
        break;
      case "write":
        accessValue = "w";
        break;
      case "access":
        accessValue = "a";
        break;
      default:
        accessValue = null;
    }
    if (!accessValue) {
      continue;
    }
    permissionMap.get(name).add(accessValue);
  }
  return Array.from(permissionMap.entries()).map(([name, accesses]) => `${name}:${Array.from(accesses).sort().join("")}`).sort().join(",");
}

// src/plugins/devServer.ts
function appsInTossDevServer(options) {
  return {
    name: "apps-in-toss:dev-server",
    config: {
      metro: {
        middlewares: [createServerPermissionsMiddleware(options.permissions)]
      }
    }
  };
}

// src/plugins/notice.ts
init_cjs_shims();

// src/plugins/resolve.ts
init_cjs_shims();
var import_module = __toESM(require("module"), 1);
function getRequire() {
  return typeof require === "function" ? require : import_module.default.createRequire(importMetaUrl);
}
function requireMicroFrontendRuntime() {
  const require2 = getRequire();
  const runtimePath = require2.resolve("@granite-js/plugin-micro-frontend/runtime");
  return {
    name: "apps-in-toss-micro-frontend",
    config: {
      resolver: {
        alias: [
          {
            from: "@granite-js/plugin-micro-frontend/runtime",
            to: runtimePath
          }
        ]
      }
    }
  };
}

// src/utils/generateDeploymentId.ts
init_cjs_shims();
var import_uuidv7 = require("uuidv7");
function generateDeploymentId() {
  return (0, import_uuidv7.uuidv7)();
}

// src/utils/setupRuntimeSetupScript.ts
init_cjs_shims();
var import_node_fs2 = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);
var import_utils6 = require("@granite-js/utils");
var import_esbuild = require("esbuild");
function setupHostRuntimeSetupScript(metadata) {
  const script = getRuntimeSetupScript(metadata, HOST_CONTEXT_IDENTIFIER);
  const setupScriptPath = writeRuntimeSetupScript(script);
  return { contents: script, path: setupScriptPath };
}
function getRuntimeSetupScript(metadata, identifier) {
  const script = `
  (function (global) {
    ${getBedrockCompatScript()}
    ${identifier === HOST_CONTEXT_IDENTIFIER ? "" : getMicroFrontendCompatScript()}
    global.${identifier} = ${JSON.stringify(metadata)};
  })(
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof global !== 'undefined'
      ? global
      : typeof window !== 'undefined'
      ? window
      : this
  );
  `;
  return (0, import_esbuild.transformSync)(script, {
    minify: true,
    sourcemap: false,
    banner: "// Runtime setup script"
  }).code;
}
function writeRuntimeSetupScript(script) {
  const packageRoot = (0, import_utils6.getPackageRoot)();
  const granitePath = import_node_path.default.join(packageRoot, ".granite");
  try {
    import_node_fs2.default.accessSync(granitePath);
  } catch {
    import_node_fs2.default.mkdirSync(granitePath, { recursive: true });
  }
  const envFilePath = import_node_path.default.join(granitePath, ".apps-in-toss.env.js");
  import_node_fs2.default.writeFileSync(envFilePath, script, "utf-8");
  return envFilePath;
}
function getBedrockCompatScript() {
  return `
  if (global.__bedrock_require__ == null) {
    global.__bedrock_require__ = function (id) {
      return global.__MICRO_FRONTEND__.__SHARED__[id].get();
    };
  }
  `;
}
function getMicroFrontendCompatScript() {
  return `
  function getHostContainer() {
    var microFrontendContext = global.__MICRO_FRONTEND__;
    var microFrontendInstances = microFrontendContext == null ? [] : microFrontendContext.__INSTANCES__;
    var sharedContainer = microFrontendInstances.find(function (instance) {
      return instance.name === '${MICRO_FRONTEND_HOST_NAME}';
    });
    return sharedContainer;
  }

  if (getHostContainer() == null) {
    var hostContainerShim = { name: '${MICRO_FRONTEND_HOST_NAME}', config: {} };
    var sharedModuleProxy = new Proxy({}, {
      get(target, prop) {
        var mod;

        try {
          mod = target[prop] && target[prop].get();
        } catch {}

        try {
          mod = mod || global.__bedrock_require__(prop);
        } catch {}

        if (mod == null) {
          return;
        }

        return {
          get: function () {
            return mod;
          },
          loaded: true,
        };
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      }
    });

    global.__MICRO_FRONTEND__ = {
      __INSTANCES__: [hostContainerShim],
      __SHARED__: sharedModuleProxy,
    };
    global.__MICRO_FRONTEND__.__INSTANCES__['${MICRO_FRONTEND_HOST_NAME}'] = 0;
  }
  `;
}

// src/appsInTossHost.ts
var PERMISSIONS = [];
function appsInTossHost(options) {
  const deploymentId = generateDeploymentId();
  const { contents, path: envFilePath } = setupHostRuntimeSetupScript({
    deploymentId,
    environment: getHostEnvironment()
  });
  return [
    requireMicroFrontendRuntime(),
    (0, import_plugin_micro_frontend.microFrontend)({
      name: MICRO_FRONTEND_HOST_NAME,
      remote: {
        host: options?.remote?.host ?? "localhost",
        port: options?.remote?.port ?? 8082
      },
      shared: SHRED_PACKAGES.reduce(
        (prev, curr) => ({ ...prev, [curr]: { eager: true } }),
        {}
      )
    }),
    appsInTossAppJson({ permissions: PERMISSIONS }),
    appsInTossDevServer({ permissions: PERMISSIONS }),
    appsInTossCreateArtifact(deploymentId),
    appsInTossEsbuildConfig(contents),
    appsInTossMetroConfig(envFilePath),
    bedrockCompat({ isHost: true }),
    (0, import_plugin_sentry.sentry)({ useClient: false })
  ];
}
function getHostEnvironment() {
  const environment = process.env.HOST_ENV;
  switch (environment) {
    case "alpha":
    case "live":
      return environment;
    default:
      return "live";
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  appsInTossHost
});
